<!doctype html><html lang=zh-CN data-theme=dark><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.126.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon_me.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon_me.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16.ico><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32.ico><link rel=apple-touch-icon sizes=180x180 href><meta itemprop=name content="深入了解ConcurrentHashMap"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="//localhost:1313/imgs/me.jpg"><meta itemprop=keywords content><meta property="og:type" content="article"><meta property="og:title" content="深入了解ConcurrentHashMap"><meta property="og:description" content><meta property="og:image" content="/imgs/me.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="//localhost:1313/post/java-base/concurrenthashmap/"><meta property="og:site_name" content="shuyou"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="shuyou"><meta property="article:published_time" content="2021-03-03 00:00:00 +0000 UTC"><meta property="article:modified_time" content="2024-06-09 00:00:00 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"concurrenthashmap","permalink":"//localhost:1313/post/java-base/concurrenthashmap/","title":"深入了解ConcurrentHashMap","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>深入了解ConcurrentHashMap - shuyou</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>shuyou</h1><i class=logo-line></i></a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>63</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-folder hvr-icon"></i>标签</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#1concurrenthashmap简介>1.ConcurrentHashMap简介</a></li><li><a href=#2底层数据结构>2.底层数据结构</a></li><li><a href=#3常用方法>3.常用方法</a></li><li><a href=#4小结>4.小结</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=shuyou src=/imgs/img-lazy-loading.gif data-src=/imgs/me.jpg><p class=site-author-name itemprop=name>shuyou</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>63</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>16</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/ZouShuYou title="Github → https://github.com/ZouShuYou" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2022-01-06T00:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=95151></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=222></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2020-11-29T00:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/java-base/concurrenthashmap/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/me.jpg"><meta itemprop=name content="shuyou"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="shuyou"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="深入了解ConcurrentHashMap"><meta itemprop=description content="本文将深入源码分析ConcurrentHashMap的相关内容 1.ConcurrentHashMap简介 由于HashMap是非线程安全的，所"></span><header class=post-header><h1 class=post-title itemprop="name headline">深入了解ConcurrentHashMap
<a href=https://github.com/ZouShuYou/ZouShuYou.github.io/tree/master/content/post/Java%20Base/ConcurrentHashMap.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2021-03-03 00:00:00 +0000 UTC" itemprop="dateCreated datePublished" datetime="2021-03-03 00:00:00 +0000 UTC">2021-03-03
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-06-09T00:00:00+00:00 itemprop=dateModified datetime=2024-06-09T00:00:00+00:00>2024-06-09</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/java%E9%9B%86%E5%90%88 itemprop=url rel=index><span itemprop=name>Java集合</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>5750</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>12分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/java-base/concurrenthashmap/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><blockquote><p>本文将深入源码分析ConcurrentHashMap的相关内容</p></blockquote><h3 id=1concurrenthashmap简介>1.ConcurrentHashMap简介
<a class=header-anchor href=#1concurrenthashmap%e7%ae%80%e4%bb%8b></a></h3><p>由于HashMap是非线程安全的，所以如果想在多线程下安全的操作Map，有下面几个解决方案：</p><ol><li>使用HashTable</li><li>使用Collections.synchronizedMap</li><li>使用ConcurrentHashMap</li></ol><p><strong>HashTable</strong>
HashTable类是一个线程安全的类，它的底层给几乎所有的多线程操作方法都加上了synchronized关键字，相当于锁住整个HashTable，多线程访问时，只要有一个线程访问或操作该对象，其他线程只能阻塞等待锁的释放，性能非常差，所以HashTable不推荐使用。</p><p><strong>Collections.synchronizedMap</strong>
底层也是使用对象锁来保证线程安全，本质上也相当于是全表锁。</p><p><strong>CocurrentHashMap</strong>
<strong>JDK1.7:</strong>
在JDK1.7中，采用分段锁。所谓分段锁，是将HashMap中的Entry数组进行切割，分成许多小数组即Segment,Segment继承ReetrantLock（可重入锁）。
<strong>JDK1.8</strong>
在JDK1.8中，取消了Segment分段锁，采用CAS+synchronized来保证并发安全，synchronized只锁住table数组中链表或者红黑树的头节点，只要插入节点的hash不冲突,就不会产生线程竞争。</p><p><strong>jdk1.8中的ConcurrentHashMap相比于jdk1.7 锁的粒度更小，性能更好。</strong></p><h3 id=2底层数据结构>2.底层数据结构
<a class=header-anchor href=#2%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84></a></h3><p>同jdk1.8中的HashMap一样，底层也采用了数组+链表/红黑树的数据结构，这样当hash冲突较多时，查询效率会更好。</p><p>Node和TreeNode同HashMap中的差不多，不过Node中的Value 和 next 用 volatile修饰</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> hash;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> K key;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//val和next都会在扩容时发生变化，所以加上volatile来保持可见性和禁止重排序</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>volatile</span> V val;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>volatile</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Node(<span style=color:#66d9ef>int</span> hash, K key, V val, Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> next) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>=</span> hash;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> key;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>val</span> <span style=color:#f92672>=</span> val;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> K <span style=color:#a6e22e>getKey</span>()       { <span style=color:#66d9ef>return</span> key; }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>getValue</span>()     { <span style=color:#66d9ef>return</span> val; }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>()   { <span style=color:#66d9ef>return</span> key.<span style=color:#a6e22e>hashCode</span>() <span style=color:#f92672>^</span> val.<span style=color:#a6e22e>hashCode</span>(); }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> String <span style=color:#a6e22e>toString</span>(){ <span style=color:#66d9ef>return</span> key <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>+</span> val; }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>setValue</span>(V value) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnsupportedOperationException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span>(Object o) {
</span></span><span style=display:flex><span>            Object k, v, u; Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;?</span>,<span style=color:#f92672>?&gt;</span> e;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ((o <span style=color:#66d9ef>instanceof</span> Map.<span style=color:#a6e22e>Entry</span>) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    (k <span style=color:#f92672>=</span> (e <span style=color:#f92672>=</span> (Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;?</span>,<span style=color:#f92672>?&gt;</span>)o).<span style=color:#a6e22e>getKey</span>()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    (v <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>getValue</span>()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    (k <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> k.<span style=color:#a6e22e>equals</span>(key)) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    (v <span style=color:#f92672>==</span> (u <span style=color:#f92672>=</span> val) <span style=color:#f92672>||</span> v.<span style=color:#a6e22e>equals</span>(u)));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * Virtualized support for map.get(); overridden in subclasses.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> h, Object k) {
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                    K ek;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> h <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        ((ek <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> k <span style=color:#f92672>||</span> (ek <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> k.<span style=color:#a6e22e>equals</span>(ek))))
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> e;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>while</span> ((e <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>next</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>TreeBin</strong>
TreeBin并不是红黑树的存储节点，TreeBin通过root属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在ConcurrentHashMap中TreeBin通过waiter属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span> 	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TreeBin</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span> 		<span style=color:#75715e>//指向TreeNode链表的根节点</span>
</span></span><span style=display:flex><span>        TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> root;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>volatile</span> TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> first;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>volatile</span> Thread waiter;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int</span> lockState;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 锁的状态</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> WRITER <span style=color:#f92672>=</span> 1; <span style=color:#75715e>// 持有写锁时的状态</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> WAITER <span style=color:#f92672>=</span> 2; <span style=color:#75715e>// 等待写锁时的状态</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> READER <span style=color:#f92672>=</span> 4; <span style=color:#75715e>// 增加数据时读锁的状态</span>
</span></span><span style=display:flex><span>			
</span></span><span style=display:flex><span>		<span style=color:#75715e>//构造函数 hash未 TREEBIN = -2，以b节点为头节点， 代表红黑树头节点hash&lt;0</span>
</span></span><span style=display:flex><span>        TreeBin(TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> b) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(TREEBIN, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>first</span> <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>            TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> r <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> x <span style=color:#f92672>=</span> b, next; x <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>; x <span style=color:#f92672>=</span> next) {
</span></span><span style=display:flex><span>                next <span style=color:#f92672>=</span> (TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)x.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>                x.<span style=color:#a6e22e>left</span> <span style=color:#f92672>=</span> x.<span style=color:#a6e22e>right</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    x.<span style=color:#a6e22e>parent</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                    x.<span style=color:#a6e22e>red</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    r <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    K k <span style=color:#f92672>=</span> x.<span style=color:#a6e22e>key</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> x.<span style=color:#a6e22e>hash</span>;
</span></span><span style=display:flex><span>                    Class<span style=color:#f92672>&lt;?&gt;</span> kc <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p <span style=color:#f92672>=</span> r;;) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>int</span> dir, ph;
</span></span><span style=display:flex><span>                        K pk <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>key</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> ((ph <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>hash</span>) <span style=color:#f92672>&gt;</span> h)
</span></span><span style=display:flex><span>                            dir <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (ph <span style=color:#f92672>&lt;</span> h)
</span></span><span style=display:flex><span>                            dir <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((kc <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                                  (kc <span style=color:#f92672>=</span> comparableClassFor(k)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                                 (dir <span style=color:#f92672>=</span> compareComparables(kc, k, pk)) <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>                            dir <span style=color:#f92672>=</span> tieBreakOrder(k, pk);
</span></span><span style=display:flex><span>                            TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> xp <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> ((p <span style=color:#f92672>=</span> (dir <span style=color:#f92672>&lt;=</span> 0) <span style=color:#f92672>?</span> p.<span style=color:#a6e22e>left</span> : p.<span style=color:#a6e22e>right</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                            x.<span style=color:#a6e22e>parent</span> <span style=color:#f92672>=</span> xp;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (dir <span style=color:#f92672>&lt;=</span> 0)
</span></span><span style=display:flex><span>                                xp.<span style=color:#a6e22e>left</span> <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                                xp.<span style=color:#a6e22e>right</span> <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>                            r <span style=color:#f92672>=</span> balanceInsertion(r, x);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>root</span> <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>assert</span> checkInvariants(root);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p><strong>ForwardingNode</strong>
扩容用到的数据结构，代表正在进行扩容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ForwardingNode</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> nextTable;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//hash 为 MOVED = -1 代变正在进行扩容</span>
</span></span><span style=display:flex><span>        ForwardingNode(Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(MOVED, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>nextTable</span> <span style=color:#f92672>=</span> tab;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><h3 id=3常用方法>3.常用方法
<a class=header-anchor href=#3%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95></a></h3><p><strong>put方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> V <span style=color:#a6e22e>put</span>(K key, V value) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> putVal(key, value, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>putVal</span>(K key, V value, <span style=color:#66d9ef>boolean</span> onlyIfAbsent) {
</span></span><span style=display:flex><span>    	<span style=color:#75715e>//key和value 都不能为null</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (key <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> value <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//获取key 的  hash</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> hash <span style=color:#f92672>=</span> spread(key.<span style=color:#a6e22e>hashCode</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> binCount <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab <span style=color:#f92672>=</span> table;;) {
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> f; <span style=color:#66d9ef>int</span> n, i, fh;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (tab <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> (n <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>            	<span style=color:#75715e>//table 为 null 或者长度为 0  初始化table</span>
</span></span><span style=display:flex><span>                tab <span style=color:#f92672>=</span> initTable();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// f 代表数组 hash&amp;（n-1）位置的元素，如果f为null 则调用casTabAt方法利用Unsafe.compareAndSwapObject插入Node节点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((f <span style=color:#f92672>=</span> tabAt(tab, i <span style=color:#f92672>=</span> (n <span style=color:#f92672>-</span> 1) <span style=color:#f92672>&amp;</span> hash)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (casTabAt(tab, i, <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>                             <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>(hash, key, value, <span style=color:#66d9ef>null</span>)))
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;                   <span style=color:#75715e>// no lock when adding to empty bin</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>//MOVED = -1 如果f.hash等于 -1 意味着有其它线程正在扩容，则当前线程一起进行扩容</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((fh <span style=color:#f92672>=</span> f.<span style=color:#a6e22e>hash</span>) <span style=color:#f92672>==</span> MOVED)
</span></span><span style=display:flex><span>            	<span style=color:#75715e>//如果在进行扩容，则先进行扩容操作</span>
</span></span><span style=display:flex><span>                tab <span style=color:#f92672>=</span> helpTransfer(tab, f);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                V oldVal <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                <span style=color:#75715e>//锁住链表或红黑树的头节点</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (f) {
</span></span><span style=display:flex><span>                	<span style=color:#75715e>//再次确认，防止其他线程修改</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (tabAt(tab, i) <span style=color:#f92672>==</span> f) {
</span></span><span style=display:flex><span>                    	<span style=color:#75715e>//hash &gt;=0 说明时链表的节点，如果有相等的key，则修改它的value，否则在链表尾部插入 </span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (fh <span style=color:#f92672>&gt;=</span> 0) {
</span></span><span style=display:flex><span>                            binCount <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e <span style=color:#f92672>=</span> f;; <span style=color:#f92672>++</span>binCount) {
</span></span><span style=display:flex><span>                                K ek;
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                                    ((ek <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                                     (ek <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(ek)))) {
</span></span><span style=display:flex><span>                                    oldVal <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>val</span>;
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>onlyIfAbsent)
</span></span><span style=display:flex><span>                                        e.<span style=color:#a6e22e>val</span> <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> pred <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>next</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                                    pred.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>(hash, key,
</span></span><span style=display:flex><span>                                                              value, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// f 是 TreeBin类型，则f为红黑树根节点</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (f <span style=color:#66d9ef>instanceof</span> TreeBin) {
</span></span><span style=display:flex><span>                            Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p;
</span></span><span style=display:flex><span>                            binCount <span style=color:#f92672>=</span> 2;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> ((p <span style=color:#f92672>=</span> ((TreeBin<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)f).<span style=color:#a6e22e>putTreeVal</span>(hash, key,
</span></span><span style=display:flex><span>                                                           value)) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                                oldVal <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>val</span>;
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>onlyIfAbsent)
</span></span><span style=display:flex><span>                                    p.<span style=color:#a6e22e>val</span> <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (binCount <span style=color:#f92672>!=</span> 0) {
</span></span><span style=display:flex><span>                	<span style=color:#75715e>//binCount &gt;= TREEIFY_THRESHOLD(默认是8) 则进行链表转红黑树操作</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (binCount <span style=color:#f92672>&gt;=</span> TREEIFY_THRESHOLD)
</span></span><span style=display:flex><span>                        treeifyBin(tab, i);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (oldVal <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> oldVal;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//扩容判断</span>
</span></span><span style=display:flex><span>        addCount(1L, binCount);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ol><li>对要存放的元素，利用spread方法对key的hashcode进行一次hash运算，由运算后的 hash&（n-1）来确定这个元素应该存放在数组中的位置</li><li>如果当前table没有初始化，则先初始化数组table</li><li>如果数组当前位置为null，则使用CAS操作直接放入</li><li>如果这个位置存在节点，说明发生hash碰撞，首先根据此位置元素的hash判断数组是否正在进行扩容（(fh = f.hash) == MOVED），如果正在进行扩容，则一起进行扩容</li><li>如果没正在扩容，则判断当前节点是否为链表节点，依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点；</li><li>如果这个节点的类型是TreeBin的话，直接调用红黑树的插入方法进行插入新的节点；</li><li>插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树；</li><li>对当前容器存放的元素容量进行检查，如果超过临界值（实际大小 * 加载因子）就需要进行扩容</li></ol><p><strong>initTable方法</strong>
初始化table数组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> <span style=color:#a6e22e>initTable</span>() {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab; <span style=color:#66d9ef>int</span> sc;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//table为初始化才进行初始化</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> ((tab <span style=color:#f92672>=</span> table) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> tab.<span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>        	<span style=color:#75715e>//sizeCtl默认为0 ，使用volatile修饰，当sizeCtl《0时，代表其他线程正在初始化，当前线程只需让出CPU时间片</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((sc <span style=color:#f92672>=</span> sizeCtl) <span style=color:#f92672>&lt;</span> 0)
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>yield</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 利用UnSafe.compareAndSwapInt,更改SIZECTL值为 -1 代表此时有线程在进行扩容</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (U.<span style=color:#a6e22e>compareAndSwapInt</span>(<span style=color:#66d9ef>this</span>, SIZECTL, sc, <span style=color:#f92672>-</span>1)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                	<span style=color:#75715e>//再次确认table未初始化</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((tab <span style=color:#f92672>=</span> table) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> tab.<span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> (sc <span style=color:#f92672>&gt;</span> 0) <span style=color:#f92672>?</span> sc : DEFAULT_CAPACITY;
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span>                        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> nt <span style=color:#f92672>=</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span>)<span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;?</span>,<span style=color:#f92672>?&gt;[</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                        table <span style=color:#f92672>=</span> tab <span style=color:#f92672>=</span> nt;
</span></span><span style=display:flex><span>                        sc <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> (n <span style=color:#f92672>&gt;&gt;&gt;</span> 2);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    sizeCtl <span style=color:#f92672>=</span> sc;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> tab;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>helpTransfer方法</strong>
帮助扩容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> <span style=color:#a6e22e>helpTransfer</span>(Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab, Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> f) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> nextTab; <span style=color:#66d9ef>int</span> sc;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// f 是 ForWardingNode 类型 且 f的nextTable 不为 null </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tab <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> (f <span style=color:#66d9ef>instanceof</span> ForwardingNode) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            (nextTab <span style=color:#f92672>=</span> ((ForwardingNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)f).<span style=color:#a6e22e>nextTable</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//帮忙扩容，得到一个标识</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> resizeStamp(tab.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果 nextTab 没有被并发修改 且 tab 也没有被并发修改</span>
</span></span><span style=display:flex><span>        	<span style=color:#75715e>// 且 sizeCtl  &lt; 0 （说明还在扩容） 自旋</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (nextTab <span style=color:#f92672>==</span> nextTable <span style=color:#f92672>&amp;&amp;</span> table <span style=color:#f92672>==</span> tab <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                   (sc <span style=color:#f92672>=</span> sizeCtl) <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>                 <span style=color:#75715e>// 如果 sizeCtl 无符号右移  16 不等于 rs （ sc前 16 位如果不等于标识符，则标识符变化了）</span>
</span></span><span style=display:flex><span>            	<span style=color:#75715e>// 或者 sizeCtl == rs + 1  （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span>
</span></span><span style=display:flex><span>            	<span style=color:#75715e>// 或者 sizeCtl == rs + 65535  （如果达到最大帮助线程的数量，即 65535）</span>
</span></span><span style=display:flex><span>            	<span style=color:#75715e>// 或者转移下标正在调整 （扩容结束）</span>
</span></span><span style=display:flex><span>            	<span style=color:#75715e>// 结束循环，返回 table</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> ((sc <span style=color:#f92672>&gt;&gt;&gt;</span> RESIZE_STAMP_SHIFT) <span style=color:#f92672>!=</span> rs <span style=color:#f92672>||</span> sc <span style=color:#f92672>==</span> rs <span style=color:#f92672>+</span> 1 <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                    sc <span style=color:#f92672>==</span> rs <span style=color:#f92672>+</span> MAX_RESIZERS <span style=color:#f92672>||</span> transferIndex <span style=color:#f92672>&lt;=</span> 0)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果以上都不是, 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）    </span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (U.<span style=color:#a6e22e>compareAndSwapInt</span>(<span style=color:#66d9ef>this</span>, SIZECTL, sc, sc <span style=color:#f92672>+</span> 1)) {
</span></span><span style=display:flex><span>                    transfer(tab, nextTab);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> nextTab;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> table;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>resizeStamp</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Integer.<span style=color:#a6e22e>numberOfLeadingZeros</span>(n) <span style=color:#f92672>|</span> (1 <span style=color:#f92672>&lt;&lt;</span> (RESIZE_STAMP_BITS <span style=color:#f92672>-</span> 1));
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>关于 sizeCtl 变量：</p><table><thead><tr><th>高RESIZE_STAMP_BITS位</th><th>低RESIZE_STAMP_SHIFT位</th></tr></thead><tbody><tr><td>扩容标记</td><td>并行扩容线程数 + 1</td></tr></tbody></table><p>resizeStamp 方法返回一个与table容量n大小有关的扩容标记</p><ol><li>Integer.numberOfLeadingZeros(n)用于获取当前int从高位到低位第一个1前面0的个数。</li><li>RESIZE_STAMP_BITS = 16 ， 1 &#171; (RESIZE_STAMP_BITS - 1) 后的结果是 1左移15位 也就是 0000 0000 0000 0000 1000 0000 0000 0000</li></ol><p><strong>addCount()方法</strong>
put完元素的最后，对当前元素容量大小进行检查，判断是否需要扩容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addCount</span>(<span style=color:#66d9ef>long</span> x, <span style=color:#66d9ef>int</span> check) {
</span></span><span style=display:flex><span>        CounterCell<span style=color:#f92672>[]</span> as; <span style=color:#66d9ef>long</span> b, s;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// s = sumCount() 统计容器中元素的个数，并将 BASECOUNT +1 </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((as <span style=color:#f92672>=</span> counterCells) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>!</span>U.<span style=color:#a6e22e>compareAndSwapLong</span>(<span style=color:#66d9ef>this</span>, BASECOUNT, b <span style=color:#f92672>=</span> baseCount, s <span style=color:#f92672>=</span> b <span style=color:#f92672>+</span> x)) {
</span></span><span style=display:flex><span>            CounterCell a; <span style=color:#66d9ef>long</span> v; <span style=color:#66d9ef>int</span> m;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> uncontended <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (as <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> (m <span style=color:#f92672>=</span> as.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1) <span style=color:#f92672>&lt;</span> 0 <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                (a <span style=color:#f92672>=</span> as<span style=color:#f92672>[</span>ThreadLocalRandom.<span style=color:#a6e22e>getProbe</span>() <span style=color:#f92672>&amp;</span> m<span style=color:#f92672>]</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>!</span>(uncontended <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                  U.<span style=color:#a6e22e>compareAndSwapLong</span>(a, CELLVALUE, v <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>value</span>, v <span style=color:#f92672>+</span> x))) {
</span></span><span style=display:flex><span>                fullAddCount(x, uncontended);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (check <span style=color:#f92672>&lt;=</span> 1)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            s <span style=color:#f92672>=</span> sumCount();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//check就是binCount，该值在`putVal()`里面一定是&gt;=0的，所以这个条件一定会为true</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (check <span style=color:#f92672>&gt;=</span> 0) {
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab, nt; <span style=color:#66d9ef>int</span> n, sc;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//自旋</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (s <span style=color:#f92672>&gt;=</span> (<span style=color:#66d9ef>long</span>)(sc <span style=color:#f92672>=</span> sizeCtl) <span style=color:#f92672>&amp;&amp;</span> (tab <span style=color:#f92672>=</span> table) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                   (n <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>&lt;</span> MAXIMUM_CAPACITY) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> resizeStamp(n);
</span></span><span style=display:flex><span>                <span style=color:#75715e>//已经有线程进行扩容</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (sc <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((sc <span style=color:#f92672>&gt;&gt;&gt;</span> RESIZE_STAMP_SHIFT) <span style=color:#f92672>!=</span> rs <span style=color:#f92672>||</span> sc <span style=color:#f92672>==</span> rs <span style=color:#f92672>+</span> 1 <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                        sc <span style=color:#f92672>==</span> rs <span style=color:#f92672>+</span> MAX_RESIZERS <span style=color:#f92672>||</span> (nt <span style=color:#f92672>=</span> nextTable) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                        transferIndex <span style=color:#f92672>&lt;=</span> 0)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//CAS  SIZECTL  增加一个线程帮助扩容</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (U.<span style=color:#a6e22e>compareAndSwapInt</span>(<span style=color:#66d9ef>this</span>, SIZECTL, sc, sc <span style=color:#f92672>+</span> 1))
</span></span><span style=display:flex><span>                        transfer(tab, nt);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 它是第一个扩容的线程，  SIZECTL  低16位 置为 0000 0000 0000 0010 </span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (U.<span style=color:#a6e22e>compareAndSwapInt</span>(<span style=color:#66d9ef>this</span>, SIZECTL, sc,
</span></span><span style=display:flex><span>                                             (rs <span style=color:#f92672>&lt;&lt;</span> RESIZE_STAMP_SHIFT) <span style=color:#f92672>+</span> 2))
</span></span><span style=display:flex><span>                    transfer(tab, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                s <span style=color:#f92672>=</span> sumCount();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>transfer() 方法</strong>
扩容方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>transfer</span>(Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab, Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> nextTab) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>, stride;
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 将 n / 8 然后除以 CPU核心数。如果得到的结果小于 16，那么就使用 16。</span>
</span></span><span style=display:flex><span>    	<span style=color:#75715e>// 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((stride <span style=color:#f92672>=</span> (NCPU <span style=color:#f92672>&gt;</span> 1) <span style=color:#f92672>?</span> (n <span style=color:#f92672>&gt;&gt;&gt;</span> 3) <span style=color:#f92672>/</span> NCPU : n) <span style=color:#f92672>&lt;</span> MIN_TRANSFER_STRIDE)
</span></span><span style=display:flex><span>            stride <span style=color:#f92672>=</span> MIN_TRANSFER_STRIDE; <span style=color:#75715e>// subdivide range</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 新的 table 尚未初始化</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nextTab <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {            <span style=color:#75715e>// initiating</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span>                <span style=color:#75715e>//新tab大小 为原来的2倍</span>
</span></span><span style=display:flex><span>                Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> nt <span style=color:#f92672>=</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span>)<span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;?</span>,<span style=color:#f92672>?&gt;[</span>n <span style=color:#f92672>&lt;&lt;</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                nextTab <span style=color:#f92672>=</span> nt;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Throwable ex) {      <span style=color:#75715e>// try to cope with OOME</span>
</span></span><span style=display:flex><span>                sizeCtl <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>MAX_VALUE</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            nextTable <span style=color:#f92672>=</span> nextTab;
</span></span><span style=display:flex><span>            transferIndex <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> nextn <span style=color:#f92672>=</span> nextTab.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        ForwardingNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> fwd <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ForwardingNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>(nextTab);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> advance <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> finishing <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// to ensure sweep before committing nextTab</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 死循环,i 表示下标，bound 表示当前线程可以处理的当前桶区间最小下标</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, bound <span style=color:#f92672>=</span> 0;;) {
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> f; <span style=color:#66d9ef>int</span> fh;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (advance) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> nextIndex, nextBound;
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 对 i 减一，判断是否大于等于 bound （正常情况下，如果大于 bound 不成立，说明该线程上次领取的任务已经完成了。那么，需要在下面继续领取任务）</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果对 i 减一大于等于 bound（还需要继续做任务），或者完成了，修改推进状态为 false，不能推进了。任务成功后修改推进状态为 true。</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通常，第一次进入循环，i-- 这个判断会无法通过，从而走下面的 nextIndex 赋值操作（获取最新的转移下标）。其余情况都是：如果可以推进，将 i 减一，然后修改成不可推进。如果 i 对应的桶处理成功了，改成可以推进。</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--</span>i <span style=color:#f92672>&gt;=</span> bound <span style=color:#f92672>||</span> finishing)
</span></span><span style=display:flex><span>                    advance <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((nextIndex <span style=color:#f92672>=</span> transferIndex) <span style=color:#f92672>&lt;=</span> 0) {
</span></span><span style=display:flex><span>                    i <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>                    advance <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (U.<span style=color:#a6e22e>compareAndSwapInt</span>
</span></span><span style=display:flex><span>                         (<span style=color:#66d9ef>this</span>, TRANSFERINDEX, nextIndex,
</span></span><span style=display:flex><span>                          nextBound <span style=color:#f92672>=</span> (nextIndex <span style=color:#f92672>&gt;</span> stride <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                                       nextIndex <span style=color:#f92672>-</span> stride : 0))) {
</span></span><span style=display:flex><span>                    bound <span style=color:#f92672>=</span> nextBound;
</span></span><span style=display:flex><span>                    i <span style=color:#f92672>=</span> nextIndex <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>                    advance <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> 0 <span style=color:#f92672>||</span> i <span style=color:#f92672>&gt;=</span> n <span style=color:#f92672>||</span> i <span style=color:#f92672>+</span> n <span style=color:#f92672>&gt;=</span> nextn) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> sc;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (finishing) {
</span></span><span style=display:flex><span>                    nextTable <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                    table <span style=color:#f92672>=</span> nextTab;
</span></span><span style=display:flex><span>                    sizeCtl <span style=color:#f92672>=</span> (n <span style=color:#f92672>&lt;&lt;</span> 1) <span style=color:#f92672>-</span> (n <span style=color:#f92672>&gt;&gt;&gt;</span> 1);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (U.<span style=color:#a6e22e>compareAndSwapInt</span>(<span style=color:#66d9ef>this</span>, SIZECTL, sc <span style=color:#f92672>=</span> sizeCtl, sc <span style=color:#f92672>-</span> 1)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((sc <span style=color:#f92672>-</span> 2) <span style=color:#f92672>!=</span> resizeStamp(n) <span style=color:#f92672>&lt;&lt;</span> RESIZE_STAMP_SHIFT)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                    finishing <span style=color:#f92672>=</span> advance <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    i <span style=color:#f92672>=</span> n; <span style=color:#75715e>// recheck before commit</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((f <span style=color:#f92672>=</span> tabAt(tab, i)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                advance <span style=color:#f92672>=</span> casTabAt(tab, i, <span style=color:#66d9ef>null</span>, fwd);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((fh <span style=color:#f92672>=</span> f.<span style=color:#a6e22e>hash</span>) <span style=color:#f92672>==</span> MOVED)
</span></span><span style=display:flex><span>                advance <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// already processed</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>synchronized</span> (f) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (tabAt(tab, i) <span style=color:#f92672>==</span> f) {
</span></span><span style=display:flex><span>                        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> ln, hn;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (fh <span style=color:#f92672>&gt;=</span> 0) {
</span></span><span style=display:flex><span>                        	<span style=color:#75715e>// hash &amp; n 之后，因 n为 2^m 判断 m位 为0 还是1 </span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>int</span> runBit <span style=color:#f92672>=</span> fh <span style=color:#f92672>&amp;</span> n;
</span></span><span style=display:flex><span>                            Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> lastRun <span style=color:#f92672>=</span> f;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p <span style=color:#f92672>=</span> f.<span style=color:#a6e22e>next</span>; p <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>; p <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>next</span>) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> n;
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>!=</span> runBit) {
</span></span><span style=display:flex><span>                                    runBit <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>                                    lastRun <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>//为0  则 低位是 lastRun</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (runBit <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                                ln <span style=color:#f92672>=</span> lastRun;
</span></span><span style=display:flex><span>                                hn <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>//否则 高位是 lastRun</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                hn <span style=color:#f92672>=</span> lastRun;
</span></span><span style=display:flex><span>                                ln <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>//遍历链表 找到ln 或 hn</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p <span style=color:#f92672>=</span> f; p <span style=color:#f92672>!=</span> lastRun; p <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>next</span>) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>int</span> ph <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>hash</span>; K pk <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>key</span>; V pv <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>val</span>;
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> ((ph <span style=color:#f92672>&amp;</span> n) <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>                                    ln <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>(ph, pk, pv, ln);
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                                    hn <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>(ph, pk, pv, hn);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>//利用CAS  交换到nextTab 并 将tab[i]  标记为正在扩容</span>
</span></span><span style=display:flex><span>                            setTabAt(nextTab, i, ln);
</span></span><span style=display:flex><span>                            setTabAt(nextTab, i <span style=color:#f92672>+</span> n, hn);
</span></span><span style=display:flex><span>                            setTabAt(tab, i, fwd);
</span></span><span style=display:flex><span>                            advance <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (f <span style=color:#66d9ef>instanceof</span> TreeBin) {
</span></span><span style=display:flex><span>                            TreeBin<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> t <span style=color:#f92672>=</span> (TreeBin<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)f;
</span></span><span style=display:flex><span>                            TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> lo <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>, loTail <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                            TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> hi <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>, hiTail <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>int</span> lc <span style=color:#f92672>=</span> 0, hc <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e <span style=color:#f92672>=</span> t.<span style=color:#a6e22e>first</span>; e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>; e <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>next</span>) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>hash</span>;
</span></span><span style=display:flex><span>                                TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>                                    (h, e.<span style=color:#a6e22e>key</span>, e.<span style=color:#a6e22e>val</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> ((h <span style=color:#f92672>&amp;</span> n) <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> ((p.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> loTail) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                                        lo <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                                        loTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                                    loTail <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                                    <span style=color:#f92672>++</span>lc;
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>if</span> ((p.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> hiTail) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                                        hi <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                                        hiTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                                    hiTail <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>                                    <span style=color:#f92672>++</span>hc;
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            ln <span style=color:#f92672>=</span> (lc <span style=color:#f92672>&lt;=</span> UNTREEIFY_THRESHOLD) <span style=color:#f92672>?</span> untreeify(lo) :
</span></span><span style=display:flex><span>                                (hc <span style=color:#f92672>!=</span> 0) <span style=color:#f92672>?</span> <span style=color:#66d9ef>new</span> TreeBin<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>(lo) : t;
</span></span><span style=display:flex><span>                            hn <span style=color:#f92672>=</span> (hc <span style=color:#f92672>&lt;=</span> UNTREEIFY_THRESHOLD) <span style=color:#f92672>?</span> untreeify(hi) :
</span></span><span style=display:flex><span>                                (lc <span style=color:#f92672>!=</span> 0) <span style=color:#f92672>?</span> <span style=color:#66d9ef>new</span> TreeBin<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>(hi) : t;
</span></span><span style=display:flex><span>                            setTabAt(nextTab, i, ln);
</span></span><span style=display:flex><span>                            setTabAt(nextTab, i <span style=color:#f92672>+</span> n, hn);
</span></span><span style=display:flex><span>                            setTabAt(tab, i, fwd);
</span></span><span style=display:flex><span>                            advance <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ol><li><p>通过计算 CPU 核心数和 Map 数组的长度得到每个线程（CPU）要帮助处理多少个桶，并且这里每个线程处理都是平均的。默认每个线程处理 16 个桶。因此，如果长度是 16 的时候，扩容的时候只会有一个线程扩容。</p></li><li><p>初始化临时变量 nextTable。将其在原有基础上扩容两倍。</p></li><li><p>死循环开始转移。多线程并发转移就是在这个死循环中，根据一个 finishing 变量来判断，该变量为 true 表示扩容结束，否则继续扩容。</p><p>3.1 进入一个 while 循环，分配数组中一个桶的区间给线程，默认是 16. 从大到小进行分配。当拿到分配值后，进行 i&ndash; 递减。这个 i 就是数组下标。（其中有一个 bound 参数，这个参数指的是该线程此次可以处理的区间的最小下标，超过这个下标，就需要重新领取区间或者结束扩容，还有一个 advance 参数，该参数指的是是否继续递减转移下一个桶，如果为 true，表示可以继续向后推进，反之，说明还没有处理好当前桶，不能推进)</p><p>3.2 出 while 循环，进 if 判断，判断扩容是否结束，如果扩容结束，清空临死变量，更新 table 变量，更新库容阈值。如果没完成，但已经无法领取区间（没了），该线程退出该方法，并将 sizeCtl 减一，表示扩容的线程少一个了。如果减完这个数以后，sizeCtl 回归了初始状态，表示没有线程再扩容了，该方法所有的线程扩容结束了。（这里主要是判断扩容任务是否结束，如果结束了就让线程退出该方法，并更新相关变量）。然后检查所有的桶，防止遗漏。</p><p>3.3 如果没有完成任务，且 i 对应的槽位是空，尝试 CAS 插入占位符，让 putVal 方法的线程感知。</p><p>3.4 如果 i 对应的槽位不是空，且有了占位符，那么该线程跳过这个槽位，处理下一个槽位。</p><p>3.5 如果以上都是不是，说明这个槽位有一个实际的值。开始同步处理这个桶。</p><p>3.6 到这里，都还没有对桶内数据进行转移，只是计算了下标和处理区间，然后一些完成状态判断。同时，如果对应下标内没有数据或已经被占位了，就跳过了。</p></li><li><p>锁住头结点，同步处理</p><p>4.1 链表，那么就将这个链表根据 length 取于拆成两份，取于结果是 0 的放在新表的低位，取于结果是 1 放在新表的高位。</p><p>4.2 红黑数，那么也拆成 2 份，方式和链表的方式一样，然后，判断拆分过的树的节点数量，如果数量小于等于 6，改造成链表。反之，继续使用红黑树结构。</p></li></ol><h3 id=4小结>4.小结
<a class=header-anchor href=#4%e5%b0%8f%e7%bb%93></a></h3><ol><li>不采用Segment而采用内部类Node作为数组，锁住链表或红黑树的头结点来减小锁粒度</li><li>不允许有 null Key 和 null Value</li><li>扩容时，允许多线程帮助进行扩容，新数组长度为原来的2倍</li><li>大量使用了CAS相关操作，定义了许多特殊的数据结构和变量，比如ForwardingNode和sizeCtl</li></ol><p><strong>参考链接</strong></p><ol><li><a href=https://www.jianshu.com/p/2829fe36a8dd title="ConcurrentHashMap#transfer() 扩容逐行分析" rel="noopener external nofollow noreferrer" target=_blank class=exturl>ConcurrentHashMap#transfer() 扩容逐行分析
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://cnblogs.com/yangming1996/p/8031199.html title="为并发而生的 ConcurrentHashMap（Java 8）" rel="noopener external nofollow noreferrer" target=_blank class=exturl>为并发而生的 ConcurrentHashMap（Java 8）
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://www.cnblogs.com/study-everyday/p/6430462.html#autoid-2-2-6 title=ConcurrentHashMap原理分析 rel="noopener external nofollow noreferrer" target=_blank class=exturl>ConcurrentHashMap原理分析
<i class="fa fa-external-link-alt"></i></a></li></ol></div><footer class=post-footer><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
深入了解ConcurrentHashMap</li><li class=post-copyright-author><strong>本文作者： </strong>shuyou</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=//localhost:1313/post/java-base/concurrenthashmap/ title=深入了解ConcurrentHashMap>//localhost:1313/post/java-base/concurrenthashmap/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/java-concurrent/threadlocal/ rel=next title=深入了解ThreadLocal><i class="fa fa-chevron-left"></i> 深入了解ThreadLocal</a></div><div class="post-nav-prev post-nav-item"><a href=/post/java-base/hashmap/ rel=prev title=深入了解HashMap>深入了解HashMap
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2021 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>shuyou</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.126.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":"trueMuse","giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"//localhost:1313/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o \n\n可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄\n(Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.js defer></script></body></html>