<!doctype html><html lang=zh-CN data-theme=dark><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.126.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon_me.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon_me.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16.ico><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32.ico><link rel=apple-touch-icon sizes=180x180 href><meta itemprop=name content="深入了解HashMap"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="//localhost:1313/imgs/me.jpg"><meta itemprop=keywords content><meta property="og:type" content="article"><meta property="og:title" content="深入了解HashMap"><meta property="og:description" content><meta property="og:image" content="/imgs/me.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="//localhost:1313/post/java-base/hashmap/"><meta property="og:site_name" content="shuyou"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="shuyou"><meta property="article:published_time" content="2021-03-02 00:00:00 +0000 UTC"><meta property="article:modified_time" content="2024-06-09 00:00:00 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"hashmap","permalink":"//localhost:1313/post/java-base/hashmap/","title":"深入了解HashMap","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>深入了解HashMap - shuyou</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>shuyou</h1><i class=logo-line></i></a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>63</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-folder hvr-icon"></i>标签</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#1-hashmap简介>1. HashMap简介</a></li><li><a href=#2-hashmap底层数据结构>2. HashMap底层数据结构</a></li><li><a href=#3hashmap常用方法>3.HashMap常用方法</a></li><li><a href=#小结>小结</a></li><li><a href=#4常见面试题>4.常见面试题</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=shuyou src=/imgs/img-lazy-loading.gif data-src=/imgs/me.jpg><p class=site-author-name itemprop=name>shuyou</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>63</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>16</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/ZouShuYou title="Github → https://github.com/ZouShuYou" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2022-01-06T00:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=95151></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=222></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2020-11-29T00:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/java-base/hashmap/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/me.jpg"><meta itemprop=name content="shuyou"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="shuyou"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="深入了解HashMap"><meta itemprop=description content="本篇分析HashMap的 hash()函数 和 底层数据结构 以及 常用方法 和 常见面试相关题目 1. HashMap简介 HashMap 是一个K，V键值对的常用集合类，它"></span><header class=post-header><h1 class=post-title itemprop="name headline">深入了解HashMap
<a href=https://github.com/ZouShuYou/ZouShuYou.github.io/tree/master/content/post/Java%20Base/HashMap.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2021-03-02 00:00:00 +0000 UTC" itemprop="dateCreated datePublished" datetime="2021-03-02 00:00:00 +0000 UTC">2021-03-02
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-06-09T00:00:00+00:00 itemprop=dateModified datetime=2024-06-09T00:00:00+00:00>2024-06-09</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/java%E9%9B%86%E5%90%88 itemprop=url rel=index><span itemprop=name>Java集合</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4069</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/java-base/hashmap/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><blockquote><p>本篇分析HashMap的 hash()函数 和 底层数据结构 以及 常用方法 和 常见面试相关题目</p></blockquote><h3 id=1-hashmap简介>1. HashMap简介
<a class=header-anchor href=#1-hashmap%e7%ae%80%e4%bb%8b></a></h3><p>HashMap 是一个K，V键值对的常用集合类，它实现了Map接口。
jdk1.8 之前 HashMap 采用 数组 + 链表 的方式实现，链表存储key值冲突的数据。
jdk1.8 采用 数组 + 链表 / 红黑树 的方式实现，在满足下面两个条件之后，会执行链表转红黑树操作，以此来加快搜索速度。</p><ul><li>链表长度大于阈值（默认为 8）</li><li>HashMap 数组长度超过 64</li></ul><h3 id=2-hashmap底层数据结构>2. HashMap底层数据结构
<a class=header-anchor href=#2-hashmap%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84></a></h3><p><strong>类的属性</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> AbstractMap<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Map<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>, Cloneable, Serializable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 默认的初始容量是16</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_INITIAL_CAPACITY <span style=color:#f92672>=</span> 1 <span style=color:#f92672>&lt;&lt;</span> 4;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 最大容量</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> MAXIMUM_CAPACITY <span style=color:#f92672>=</span> 1 <span style=color:#f92672>&lt;&lt;</span> 30;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 默认的填充因子</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>float</span> DEFAULT_LOAD_FACTOR <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>75f</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> TREEIFY_THRESHOLD <span style=color:#f92672>=</span> 8;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当桶(bucket)上的结点数小于这个值时树转链表</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> UNTREEIFY_THRESHOLD <span style=color:#f92672>=</span> 6;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 桶中结构转化为红黑树对应的table的最小大小</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> MIN_TREEIFY_CAPACITY <span style=color:#f92672>=</span> 64;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 存储元素的数组，大小总是2的幂次倍</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transient</span> Node<span style=color:#f92672>&lt;</span>k,v<span style=color:#f92672>&gt;[]</span> table;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 存放具体元素的集</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transient</span> Set<span style=color:#f92672>&lt;</span>map.<span style=color:#a6e22e>entry</span><span style=color:#f92672>&lt;</span>k,v<span style=color:#f92672>&gt;&gt;</span> entrySet;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 存放元素的个数，注意这个不等于数组的长度。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 每次扩容和更改map结构的计数器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>int</span> modCount;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> threshold;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加载因子</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>float</span> loadFactor;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>一些内部类</strong></p><ul><li>EntrySet、EntryIterator、EntrySpliterator 键值Set 迭代器 分离器s</li><li>KeySet、KeyIterator、KeySpliterator 键Set 迭代器 分离器</li><li>Values、ValueIterator、ValueSpliterator 值Set 迭代器 分离器</li></ul><p><em>使用</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestMap</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> test <span style=color:#f92672>=</span>  <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(test.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;A&#34;</span>,<span style=color:#e6db74>&#34;AAA&#34;</span>);
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;B&#34;</span>,<span style=color:#e6db74>&#34;BBB&#34;</span>);
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;C&#34;</span>,<span style=color:#e6db74>&#34;CCC&#34;</span>);
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;D&#34;</span>,<span style=color:#e6db74>&#34;DDD&#34;</span>);
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;E&#34;</span>,<span style=color:#e6db74>&#34;EEE&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Iterator<span style=color:#f92672>&lt;</span>Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;&gt;</span> iterator <span style=color:#f92672>=</span> test.<span style=color:#a6e22e>entrySet</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (iterator.<span style=color:#a6e22e>hasNext</span>()){
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(iterator.<span style=color:#a6e22e>next</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Iterator<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> iterator1 <span style=color:#f92672>=</span> test.<span style=color:#a6e22e>keySet</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (iterator1.<span style=color:#a6e22e>hasNext</span>()){
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(iterator1.<span style=color:#a6e22e>next</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Spliterator<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> spliterator <span style=color:#f92672>=</span> test.<span style=color:#a6e22e>values</span>().<span style=color:#a6e22e>spliterator</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(spliterator.<span style=color:#a6e22e>estimateSize</span>());
</span></span><span style=display:flex><span>        spliterator.<span style=color:#a6e22e>forEachRemaining</span>(System.<span style=color:#a6e22e>out</span>::println);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(test.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=/imgs/img-lazy-loading.gif data-src="https://img-blog.csdnimg.cn/20210301172916936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70" alt=结果></p><p><strong>Node节点类</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Entry<span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> hash; <span style=color:#75715e>//hash值，存放元素时用来与其他元素的hash值进行比较。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> K key; <span style=color:#75715e>// 键  key 唯一  一个key 一个 value  允许有一个 key为 null </span>
</span></span><span style=display:flex><span>        V value; <span style=color:#75715e>// 值</span>
</span></span><span style=display:flex><span>        HashMap.<span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;</span> next; <span style=color:#75715e>//指向下一个Node</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Node(<span style=color:#66d9ef>int</span> var1, K var2, V var3, HashMap.<span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;</span> var4) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>=</span> var1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>key</span> <span style=color:#f92672>=</span> var2;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> var3;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> var4;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> K <span style=color:#a6e22e>getKey</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>key</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>getValue</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>key</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Objects.<span style=color:#a6e22e>hashCode</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>^</span> Objects.<span style=color:#a6e22e>hashCode</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>setValue</span>(V var1) {
</span></span><span style=display:flex><span>            Object var2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> var1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> var2;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span>(Object var1) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (var1 <span style=color:#f92672>==</span> <span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (var1 <span style=color:#66d9ef>instanceof</span> Entry) {
</span></span><span style=display:flex><span>                    Entry var2 <span style=color:#f92672>=</span> (Entry)var1;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (Objects.<span style=color:#a6e22e>equals</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>key</span>, var2.<span style=color:#a6e22e>getKey</span>()) <span style=color:#f92672>&amp;&amp;</span> Objects.<span style=color:#a6e22e>equals</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span>, var2.<span style=color:#a6e22e>getValue</span>())) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>TreeNode源码</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>// 一些方法这里就不贴了</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TreeNode</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> parent;  <span style=color:#75715e>// 红黑树 父节点</span>
</span></span><span style=display:flex><span>        TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> left;
</span></span><span style=display:flex><span>        TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> right;
</span></span><span style=display:flex><span>        TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> prev;    <span style=color:#75715e>// 删除后需要取消链接</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> red;
</span></span><span style=display:flex><span>        TreeNode(<span style=color:#66d9ef>int</span> hash, K key, V val, Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> next) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(hash, key, val, next);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>数组+链表</strong>
Node&lt;k,v>[] table<br><img src=/imgs/img-lazy-loading.gif data-src="https://img-blog.csdnimg.cn/20210301175245123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70" alt=拉链>
<strong>数组+红黑树</strong>
<img src=/imgs/img-lazy-loading.gif data-src="https://img-blog.csdnimg.cn/2021030117571543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70" alt=[></p><h3 id=3hashmap常用方法>3.HashMap常用方法
<a class=header-anchor href=#3hashmap%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95></a></h3><p><strong>构造函数</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 构造一个具有指定初始容量和负载因子的空HashMap 。
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>HashMap</span>(<span style=color:#66d9ef>int</span> initialCapacity, <span style=color:#66d9ef>float</span> loadFactor) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//如果初始化大小小于0，抛出异常  </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (initialCapacity <span style=color:#f92672>&lt;</span> 0)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Illegal initial capacity: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                               initialCapacity);
</span></span><span style=display:flex><span>      <span style=color:#75715e>//HashMap 中table的最大值为2^30 如果初始化大小大于2^30，则为2^30</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (initialCapacity <span style=color:#f92672>&gt;</span> MAXIMUM_CAPACITY)
</span></span><span style=display:flex><span>            initialCapacity <span style=color:#f92672>=</span> MAXIMUM_CAPACITY;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (loadFactor <span style=color:#f92672>&lt;=</span> 0 <span style=color:#f92672>||</span> Float.<span style=color:#a6e22e>isNaN</span>(loadFactor))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Illegal load factor: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                               loadFactor);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loadFactor</span> <span style=color:#f92672>=</span> loadFactor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>threshold</span> <span style=color:#f92672>=</span> tableSizeFor(initialCapacity);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 自定义初始容量  使用默认加载因子（0.75）构造一个空的HashMap 。
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>HashMap</span>(<span style=color:#66d9ef>int</span> initialCapacity) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 使用默认的初始容量（16）和默认的加载因子（0.75）构造一个空的HashMap 。
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>HashMap</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loadFactor</span> <span style=color:#f92672>=</span> DEFAULT_LOAD_FACTOR; <span style=color:#75715e>// all other fields defaulted</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li><p>填装因子:loadFactor 表示填装因子的大小，简单的介绍一下填装因子：假设数组大小为16，每个放到数组中的元素mod 9，所有元素取模后放的位置是（0–9） 此时填装因子的大小为 9/16 ,装填因子就为0.75啦。</p></li><li><p>HashMap初始化过程就是新建一个大小为capacity，类型为Node的数组，Node上面已经介绍过这个类，包含一个指针一个key，一个value，和一个hash。capacity是2的次幂，至于为什么是2的次幂后面会有介绍的。</p></li></ul><p><strong>hash函数</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hash</span>(Object key) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> h;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//用 key 的 hashCode  高16位 与 低16位 进行 异或运算 结果放在低16位</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (key <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>?</span> 0 : (h <span style=color:#f92672>=</span> key.<span style=color:#a6e22e>hashCode</span>()) <span style=color:#f92672>^</span> (h <span style=color:#f92672>&gt;&gt;&gt;</span> 16);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>因为hashmap的 put 和 get 都要将 key 经过hash函数处理之后 与 数组大小 length -1 进行与运算，而数组的大小通常不会超过2^16，所以始终是低16位参与运算，所以将key的hashCode的高16位与低16位进行异或运算，得到的值会更具有散列的特性。</p><p><strong>put 函数</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> V <span style=color:#a6e22e>put</span>(K key, V value) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> putVal(hash(key), key, value, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>putVal</span>(<span style=color:#66d9ef>int</span> hash, K key, V value, <span style=color:#66d9ef>boolean</span> onlyIfAbsent,
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>boolean</span> evict) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab; Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p; <span style=color:#66d9ef>int</span> n, i;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//table未初始化 或者 长度为 0 进行扩容 </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((tab <span style=color:#f92672>=</span> table) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> (n <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> (tab <span style=color:#f92672>=</span> resize()).<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 确定存放的下标，如果此时为null，则新生Node 放入当前数组下标的位置。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((p <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i <span style=color:#f92672>=</span> (n <span style=color:#f92672>-</span> 1) <span style=color:#f92672>&amp;</span> hash<span style=color:#f92672>]</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            tab<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> newNode(hash, key, value, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>     	<span style=color:#75715e>//数组当前位置已存在元素</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e; K k;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//数组当前位置p 的hash 与要插入元素的hash相等 且 key 相等</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (p.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                ((k <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> (key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(k))))
</span></span><span style=display:flex><span>                <span style=color:#75715e>//当前位置p 赋值给 e</span>
</span></span><span style=display:flex><span>                e <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// hash值不等，即key不等，p为红黑树节点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (p <span style=color:#66d9ef>instanceof</span> TreeNode)
</span></span><span style=display:flex><span>            	<span style=color:#75715e>//插入红黑树</span>
</span></span><span style=display:flex><span>                e <span style=color:#f92672>=</span> ((TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)p).<span style=color:#a6e22e>putTreeVal</span>(<span style=color:#66d9ef>this</span>, tab, hash, key, value);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//为链表节点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            	<span style=color:#75715e>//在链表节点最末端插入</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> binCount <span style=color:#f92672>=</span> 0; ; <span style=color:#f92672>++</span>binCount) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>next</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    	<span style=color:#75715e>//插入最末端</span>
</span></span><span style=display:flex><span>                        p.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode(hash, key, value, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                        <span style=color:#75715e>//结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span>
</span></span><span style=display:flex><span>                    	<span style=color:#75715e>// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，否则就是只是对数组扩容。</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (binCount <span style=color:#f92672>&gt;=</span> TREEIFY_THRESHOLD <span style=color:#f92672>-</span> 1) <span style=color:#75715e>// -1 for 1st</span>
</span></span><span style=display:flex><span>                            treeifyBin(tab, hash);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//找到了key 值一样的节点 跳出循环 修改value</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        ((k <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> (key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(k))))
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    p <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 找到key值、hash值与插入元素相等的结点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) { <span style=color:#75715e>// existing mapping for key</span>
</span></span><span style=display:flex><span>                V oldValue <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>onlyIfAbsent <span style=color:#f92672>||</span> oldValue <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                	<span style=color:#75715e>//修改旧值</span>
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>                afterNodeAccess(e);
</span></span><span style=display:flex><span>                <span style=color:#75715e>//返回旧值</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> oldValue;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//结构性修改</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>modCount;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实际大小大于阈值则扩容</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>++</span>size <span style=color:#f92672>&gt;</span> threshold)
</span></span><span style=display:flex><span>            resize();
</span></span><span style=display:flex><span>        afterNodeInsertion(evict);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><img src=/imgs/img-lazy-loading.gif data-src="https://img-blog.csdnimg.cn/20210302131218700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><ol><li>先判断数组 table 是否为null 或者 长度为0，如果是则 resize() 扩容，否则根据 hash 确定存放的下标，如果此时数组对应位置为null，则新生Node 放入当前数组下标的位置。</li><li>对应位置有值，判断key是否一致，一致则直接修改value值 ，否则进行遍历在末端插入。</li><li>判断此时链表长度是否大于默认阈值（8），不大于则直接返回旧值，否则将链表转换为红黑树。</li></ol><p><strong>get函数</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> V <span style=color:#a6e22e>get</span>(Object key) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (e <span style=color:#f92672>=</span> getNode(hash(key), key)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span> : e.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getNode</span>(<span style=color:#66d9ef>int</span> hash, Object key) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab; Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> first, e; <span style=color:#66d9ef>int</span> n; K k;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((tab <span style=color:#f92672>=</span> table) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> (n <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            (first <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>(n <span style=color:#f92672>-</span> 1) <span style=color:#f92672>&amp;</span> hash<span style=color:#f92672>]</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) { <span style=color:#75715e>// hash计算出的 数组位置 第一个元素存在</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (first.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span> <span style=color:#75715e>// 数组当位置的第一个元素 hash 与要取的 hash相当 且 key相等</span>
</span></span><span style=display:flex><span>                ((k <span style=color:#f92672>=</span> first.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> (key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(k))))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> first;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> first.<span style=color:#a6e22e>next</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) { <span style=color:#75715e>// 存在第二个元素</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (first <span style=color:#66d9ef>instanceof</span> TreeNode) <span style=color:#75715e>// 第一个元素是一个树节点 调红黑树的取值方法</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> ((TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)first).<span style=color:#a6e22e>getTreeNode</span>(hash, key);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>do</span> {<span style=color:#75715e>// 链表节点  循环遍历  找到节点相等的key 和 hash</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        ((k <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> (key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(k))))
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> e;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>while</span> ((e <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>next</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 没有  返回null</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>扩容</strong>
什么时候进行扩容操作？</p><ol><li>数组 table 为null 或者长度为 0</li><li>数组中元素实际个数大于阈值 threshold 会扩容</li><li>链表中的长度超过了TREEIFY_THRESHOLD（8），但表长度却小于MIN_TREEIFY_CAPACITY（64）</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> <span style=color:#a6e22e>resize</span>() {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> oldTab <span style=color:#f92672>=</span> table;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> oldCap <span style=color:#f92672>=</span> (oldTab <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>?</span> 0 : oldTab.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> oldThr <span style=color:#f92672>=</span> threshold;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> newCap, newThr <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//旧容量大于 0 </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (oldCap <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>        	<span style=color:#75715e>//旧容量大于等于最大容量 阈值等于最大容量 并返回旧容量值</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (oldCap <span style=color:#f92672>&gt;=</span> MAXIMUM_CAPACITY) {
</span></span><span style=display:flex><span>                threshold <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>MAX_VALUE</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> oldTab;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>//新容量 为 旧容量的2倍 且 旧容量大于默认初始化容量且小于最大容量</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((newCap <span style=color:#f92672>=</span> oldCap <span style=color:#f92672>&lt;&lt;</span> 1) <span style=color:#f92672>&lt;</span> MAXIMUM_CAPACITY <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                     oldCap <span style=color:#f92672>&gt;=</span> DEFAULT_INITIAL_CAPACITY)
</span></span><span style=display:flex><span>                newThr <span style=color:#f92672>=</span> oldThr <span style=color:#f92672>&lt;&lt;</span> 1; <span style=color:#75715e>// 新阈值为 旧阈值的2倍</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (oldThr <span style=color:#f92672>&gt;</span> 0) <span style=color:#75715e>//旧容量小于等于0时 新容量 等于 旧阈值</span>
</span></span><span style=display:flex><span>            newCap <span style=color:#f92672>=</span> oldThr;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {               <span style=color:#75715e>// 阈值和容量 都初始化为默认值</span>
</span></span><span style=display:flex><span>            newCap <span style=color:#f92672>=</span> DEFAULT_INITIAL_CAPACITY;
</span></span><span style=display:flex><span>            newThr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span>)(DEFAULT_LOAD_FACTOR <span style=color:#f92672>*</span> DEFAULT_INITIAL_CAPACITY);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (newThr <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>float</span> ft <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float</span>)newCap <span style=color:#f92672>*</span> loadFactor;
</span></span><span style=display:flex><span>            newThr <span style=color:#f92672>=</span> (newCap <span style=color:#f92672>&lt;</span> MAXIMUM_CAPACITY <span style=color:#f92672>&amp;&amp;</span> ft <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>float</span>)MAXIMUM_CAPACITY <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                      (<span style=color:#66d9ef>int</span>)ft : Integer.<span style=color:#a6e22e>MAX_VALUE</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        threshold <span style=color:#f92672>=</span> newThr;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SuppressWarnings</span>({<span style=color:#e6db74>&#34;rawtypes&#34;</span>,<span style=color:#e6db74>&#34;unchecked&#34;</span>})
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> newTab <span style=color:#f92672>=</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span>)<span style=color:#66d9ef>new</span> Node<span style=color:#f92672>[</span>newCap<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        table <span style=color:#f92672>=</span> newTab;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (oldTab <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        	<span style=color:#75715e>//遍历旧数组 oldTab</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0; j <span style=color:#f92672>&lt;</span> oldCap; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>                Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> oldTab<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                	<span style=color:#75715e>//旧数组 j 位置置空</span>
</span></span><span style=display:flex><span>                    oldTab<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//只有一个值，根据hash放入新数组的对应位置</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                        newTab<span style=color:#f92672>[</span>e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> (newCap <span style=color:#f92672>-</span> 1)<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//为红黑树 </span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (e <span style=color:#66d9ef>instanceof</span> TreeNode)
</span></span><span style=display:flex><span>                        ((TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)e).<span style=color:#a6e22e>split</span>(<span style=color:#66d9ef>this</span>, newTab, j, oldCap);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 链表优化重hash的节点</span>
</span></span><span style=display:flex><span>                        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> loHead <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>, loTail <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> hiHead <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>, hiTail <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                            next <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>                            <span style=color:#75715e>//原索引</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> ((e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> oldCap) <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> (loTail <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                                    loHead <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                                    loTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                                loTail <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>//原索引 + oldCap</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> (hiTail <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                                    hiHead <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                                    hiTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                                hiTail <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>while</span> ((e <span style=color:#f92672>=</span> next) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                         <span style=color:#75715e>// 原索引放到新数组 j 上</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (loTail <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                            loTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                            newTab<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> loHead;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 原索引+oldCap放到新数组 j+oldCap 上</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (hiTail <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                            hiTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                            newTab<span style=color:#f92672>[</span>j <span style=color:#f92672>+</span> oldCap<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> hiHead;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> newTab;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=小结>小结
<a class=header-anchor href=#%e5%b0%8f%e7%bb%93></a></h3><ol><li>扩容是一个特别耗性能的操作，所以当使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>负载因子是可以修改的，也可以大于1，但是不建议轻易修改。</li><li>HashMap不是线程安全的，不要在并发环境下同时操作HashMap，建设使用ConcurrentHashMap。</li><li>JDK1.8之前 HashMap是数组+链表的实现，JDK1.8采用数组+链表/红黑树的方式实现。</li></ol><h3 id=4常见面试题>4.常见面试题
<a class=header-anchor href=#4%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98></a></h3><p><strong>1.HashMap的底层数据结构</strong>
JDK1.8之前 数组+链表
JDK1.8之后 数组+链表/红黑树</p><p><strong>2.HashMap的工作原理</strong>
HashMap底层是数组+链表，由Node内部类实现，通过put方法存放、get方法获取数据。</p><p>存储数据时，将K，V键值传给put方法</p><ol><li>调用hash(K)方法，计算K的hash值，hash&(n-1)计算此时应放的数组下标。</li><li>判断当前数组位置是否有值，没有则直接插入，有值则判断他们的key是否相等，相等则修改它的值。</li><li>否则，判断当前节点是红黑树还是链表，若是链表则遍历，在末端插入元素，若存在key相等的节点，则修改它的值，若是红黑树则遍历红黑树并插入元素</li><li>判断插入链表后，链表的长度是否大于8，如果大于且数组长度大于64，则链表转为红黑树，数组长度小于64，则数组扩容。</li><li>判断插入之后，HashMap实际元素的个数是否大于 capacity * loadfactor，大于会进行扩容。</li></ol><p>获取数据时，将K值传给get方法。</p><ol><li>调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标</li><li>遍历链表或者红黑树，equals()方法查找相同 Node 链表中 K 值对应的 V 值。</li></ol><p><strong>3.HashMap 的底层数组长度为何总是2的n次方</strong></p><ol><li>数据分布均匀，减少hash碰撞</li><li>当长度n总是2的n次方时 hash&（n-1）相当于 hash%n-1，即相当于取模运算，而且在速度、效率上比直接取模要快得多</li></ol><p><strong>4.HashMap允许空键空值么</strong>
HashMap允许Key有一个为null，允许多个Value为null</p><p><strong>5.HashMap线程安全方面会出现什么问题</strong>
JDK1.7 扩容会出现循环链或数据丢失
JDK1.8 put会出现数据覆盖</p><p><strong>参考链接</strong></p><ol><li><a href=https://tech.meituan.com/2016/06/24/java-hashmap.html title="美团技术团队 Java 8系列之重新认识HashMap" rel="noopener external nofollow noreferrer" target=_blank class=exturl>美团技术团队 Java 8系列之重新认识HashMap
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap%28JDK1.8%29%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md title="JavaGuide HashMap(JDK1.8)源码+底层数据结构分析" rel="noopener external nofollow noreferrer" target=_blank class=exturl>JavaGuide HashMap(JDK1.8)源码+底层数据结构分析
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://www.cnblogs.com/java1024/p/13488714.html title="HashMap 常见面试题" rel="noopener external nofollow noreferrer" target=_blank class=exturl>HashMap 常见面试题
<i class="fa fa-external-link-alt"></i></a></li></ol></div><footer class=post-footer><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
深入了解HashMap</li><li class=post-copyright-author><strong>本文作者： </strong>shuyou</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=//localhost:1313/post/java-base/hashmap/ title=深入了解HashMap>//localhost:1313/post/java-base/hashmap/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/java-base/concurrenthashmap/ rel=next title=深入了解ConcurrentHashMap><i class="fa fa-chevron-left"></i> 深入了解ConcurrentHashMap</a></div><div class="post-nav-prev post-nav-item"><a href=/post/java-base/java%E9%9B%86%E5%90%88%E5%B0%8F%E7%BB%93/ rel=prev title=Java集合小结>Java集合小结
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2021 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>shuyou</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.126.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":"trueMuse","giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"//localhost:1313/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o \n\n可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄\n(Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.js defer></script></body></html>